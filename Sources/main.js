/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/parse-ms/index.js
var require_parse_ms = __commonJS({
  "node_modules/parse-ms/index.js"(exports, module2) {
    "use strict";
    module2.exports = (milliseconds) => {
      if (typeof milliseconds !== "number") {
        throw new TypeError("Expected a number");
      }
      const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
      return {
        days: roundTowardsZero(milliseconds / 864e5),
        hours: roundTowardsZero(milliseconds / 36e5) % 24,
        minutes: roundTowardsZero(milliseconds / 6e4) % 60,
        seconds: roundTowardsZero(milliseconds / 1e3) % 60,
        milliseconds: roundTowardsZero(milliseconds) % 1e3,
        microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
        nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
      };
    };
  }
});

// node_modules/pretty-ms/index.js
var require_pretty_ms = __commonJS({
  "node_modules/pretty-ms/index.js"(exports, module2) {
    "use strict";
    var parseMilliseconds = require_parse_ms();
    var pluralize = (word, count) => count === 1 ? word : `${word}s`;
    var SECOND_ROUNDING_EPSILON = 1e-7;
    module2.exports = (milliseconds, options = {}) => {
      if (!Number.isFinite(milliseconds)) {
        throw new TypeError("Expected a finite number");
      }
      if (options.colonNotation) {
        options.compact = false;
        options.formatSubMilliseconds = false;
        options.separateMilliseconds = false;
        options.verbose = false;
      }
      if (options.compact) {
        options.secondsDecimalDigits = 0;
        options.millisecondsDecimalDigits = 0;
      }
      const result = [];
      const floorDecimals = (value, decimalDigits) => {
        const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
        const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
        return flooredValue.toFixed(decimalDigits);
      };
      const add = (value, long, short, valueString) => {
        if ((result.length === 0 || !options.colonNotation) && value === 0 && !(options.colonNotation && short === "m")) {
          return;
        }
        valueString = (valueString || value || "0").toString();
        let prefix;
        let suffix;
        if (options.colonNotation) {
          prefix = result.length > 0 ? ":" : "";
          suffix = "";
          const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
          const minLength = result.length > 0 ? 2 : 1;
          valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
        } else {
          prefix = "";
          suffix = options.verbose ? " " + pluralize(long, value) : short;
        }
        result.push(prefix + valueString + suffix);
      };
      const parsed = parseMilliseconds(milliseconds);
      add(Math.trunc(parsed.days / 365), "year", "y");
      add(parsed.days % 365, "day", "d");
      add(parsed.hours, "hour", "h");
      add(parsed.minutes, "minute", "m");
      if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1e3) {
        add(parsed.seconds, "second", "s");
        if (options.formatSubMilliseconds) {
          add(parsed.milliseconds, "millisecond", "ms");
          add(parsed.microseconds, "microsecond", "\xB5s");
          add(parsed.nanoseconds, "nanosecond", "ns");
        } else {
          const millisecondsAndBelow = parsed.milliseconds + parsed.microseconds / 1e3 + parsed.nanoseconds / 1e6;
          const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
          const roundedMiliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
          const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMiliseconds;
          add(
            Number.parseFloat(millisecondsString, 10),
            "millisecond",
            "ms",
            millisecondsString
          );
        }
      } else {
        const seconds = milliseconds / 1e3 % 60;
        const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
        const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
        const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
        add(Number.parseFloat(secondsString, 10), "second", "s", secondsString);
      }
      if (result.length === 0) {
        return "0" + (options.verbose ? " milliseconds" : "ms");
      }
      if (options.compact) {
        return result[0];
      }
      if (typeof options.unitCount === "number") {
        const separator = options.colonNotation ? "" : " ";
        return result.slice(0, Math.max(options.unitCount, 1)).join(separator);
      }
      return options.colonNotation ? result.join("") : result.join(" ");
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ReadingTime
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var RT_DEFAULT_SETTINGS = {
  readingSpeed: 200,
  format: "default" /* Default */,
  appendText: "read"
};
var ReadingTimeSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Reading speed").setDesc("Words per minute used for reading speed (default: 200).").addText((text) => {
      text.setPlaceholder("Example: 200").setValue(this.plugin.settings.readingSpeed.toString()).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.readingSpeed = parseInt(value.trim());
        yield this.plugin.saveSettings().then(this.plugin.calculateReadingTime);
      }));
    });
    new import_obsidian.Setting(this.containerEl).setName("Format").setDesc("Choose the output format").addDropdown(
      (dropdown) => dropdown.addOption("default" /* Default */, "Default (10 min)").addOption("compact" /* Compact */, "Compact (10m)").addOption("simple" /* Simple */, "Simple (10m 4s)").addOption(
        "verbose" /* Verbose */,
        "Verbose (10 minutes 4 seconds)"
      ).addOption("digital" /* Digital */, "Colon Notation (10:04)").setValue(this.plugin.settings.format).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.format = value;
        yield this.plugin.saveSettings().then(this.plugin.calculateReadingTime);
      }))
    );
    new import_obsidian.Setting(this.containerEl).setName("Append Text").setDesc("Append 'read' to formatted string.").addText(
      (text) => text.setValue(this.plugin.settings.appendText).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.appendText = value.trim();
        yield this.plugin.saveSettings().then(this.plugin.calculateReadingTime);
      }))
    );
  }
};

// src/lib/reading-time/index.ts
function codeIsInRanges(number, arrayOfRanges) {
  return arrayOfRanges.some(
    ([lowerBound, upperBound]) => lowerBound <= number && number <= upperBound
  );
}
var isCJK = (c) => {
  const charCode = c.charCodeAt(0);
  return codeIsInRanges(charCode, [
    // Hiragana (Katakana not included on purpose,
    // context: https://github.com/ngryman/reading-time/pull/35#issuecomment-853364526)
    // If you think Katakana should be included and have solid reasons, improvement is welcomed
    [12352, 12447],
    // CJK Unified ideographs
    [19968, 40959],
    // Hangul
    [44032, 55203],
    // CJK extensions
    [131072, 191456]
  ]);
};
var isAnsiWordBound = (c) => {
  return " \n\r	".includes(c);
};
var isPunctuation = (c) => {
  const charCode = c.charCodeAt(0);
  return codeIsInRanges(charCode, [
    [33, 47],
    [58, 64],
    [91, 96],
    [123, 126],
    // CJK Symbols and Punctuation
    [12288, 12351],
    // Full-width ASCII punctuation variants
    [65280, 65519]
  ]);
};
function countWords(text, options = {}) {
  let words = 0, start = 0, end = text.length - 1;
  const { wordBound: isWordBound = isAnsiWordBound } = options;
  while (isWordBound(text[start]))
    start++;
  while (isWordBound(text[end]))
    end--;
  const normalizedText = `${text}
`;
  for (let i = start; i <= end; i++) {
    if (isCJK(normalizedText[i]) || !isWordBound(normalizedText[i]) && (isWordBound(normalizedText[i + 1]) || isCJK(normalizedText[i + 1]))) {
      words++;
    }
    if (isCJK(normalizedText[i])) {
      while (i <= end && (isPunctuation(normalizedText[i + 1]) || isWordBound(normalizedText[i + 1]))) {
        i++;
      }
    }
  }
  return { total: words };
}
function readingTimeWithCount(words, options = {}) {
  const { wordsPerMinute = 200 } = options;
  const minutes = words.total / wordsPerMinute;
  const time = Math.round(minutes * 60 * 1e3);
  const displayed = Math.ceil(parseFloat(minutes.toFixed(2)));
  return {
    minutes: displayed,
    time
  };
}
function readingTime(text, options = {}) {
  const words = countWords(text, options);
  return __spreadProps(__spreadValues({}, readingTimeWithCount(words, options)), {
    words
  });
}

// src/helpers.ts
var import_pretty_ms = __toESM(require_pretty_ms());
function readingTimeText(text, plugin) {
  const result = readingTime(text, {
    wordsPerMinute: plugin.settings.readingSpeed
  });
  let options = { secondsDecimalDigits: 0 };
  switch (plugin.settings.format) {
    case "simple" /* Simple */:
      break;
    case "compact" /* Compact */:
      if (result.time > 36e5) {
        options = __spreadProps(__spreadValues({}, options), { unitCount: 2 });
      } else {
        options = __spreadProps(__spreadValues({}, options), { compact: true });
      }
      break;
    case "verbose" /* Verbose */:
      options = __spreadProps(__spreadValues({}, options), { verbose: true });
      break;
    case "digital" /* Digital */:
      options = __spreadProps(__spreadValues({}, options), { colonNotation: true });
      break;
    case "default" /* Default */:
    default:
      return plugin.settings.appendText ? `${result.minutes} min read` : `${result.minutes} min`;
  }
  const output = (0, import_pretty_ms.default)(result.time, options);
  return plugin.settings.appendText ? `${output} ${plugin.settings.appendText}` : output;
}

// src/main.ts
var ReadingTime = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.calculateReadingTime = () => {
      const mdView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (mdView && mdView.getViewData()) {
        const result = readingTimeText(mdView.getViewData(), this);
        this.statusBar.setText(`${result}`);
      } else {
        this.statusBar.setText("0 min read");
      }
    };
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.statusBar = this.addStatusBarItem();
      this.statusBar.setText("");
      this.addSettingTab(new ReadingTimeSettingsTab(this.app, this));
      this.addCommand({
        id: "reading-time-editor-command",
        name: "Selected Text",
        editorCallback: (editor, view) => {
          new ReadingTimeModal(this.app, editor, this).open();
        }
      });
      this.registerEvent(
        this.app.workspace.on("layout-change", this.calculateReadingTime)
      );
      this.registerEvent(
        this.app.workspace.on("file-open", this.calculateReadingTime)
      );
      this.registerEvent(
        this.app.workspace.on(
          "editor-change",
          (0, import_obsidian2.debounce)(this.calculateReadingTime, 1e3)
        )
      );
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign(
        {},
        RT_DEFAULT_SETTINGS,
        yield this.loadData()
      );
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var ReadingTimeModal = class extends import_obsidian2.Modal {
  constructor(app, editor, plugin) {
    super(app);
    this.editor = editor;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Reading Time of Selected Text");
    const stats = readingTimeText(this.editor.getSelection(), this.plugin);
    contentEl.setText(`${stats} (at ${this.plugin.settings.readingSpeed} wpm)`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
/*!
 * reading-time
 * Copyright (c) Nicolas Gryman <ngryman@gmail.com>
 * MIT Licensed
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3BhcnNlLW1zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9wcmV0dHktbXMvaW5kZXguanMiLCAic3JjL21haW4udHMiLCAic3JjL3NldHRpbmdzLnRzIiwgInNyYy9saWIvcmVhZGluZy10aW1lL2luZGV4LnRzIiwgInNyYy9oZWxwZXJzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IG1pbGxpc2Vjb25kcyA9PiB7XG5cdGlmICh0eXBlb2YgbWlsbGlzZWNvbmRzICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbnVtYmVyJyk7XG5cdH1cblxuXHRjb25zdCByb3VuZFRvd2FyZHNaZXJvID0gbWlsbGlzZWNvbmRzID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWw7XG5cblx0cmV0dXJuIHtcblx0XHRkYXlzOiByb3VuZFRvd2FyZHNaZXJvKG1pbGxpc2Vjb25kcyAvIDg2NDAwMDAwKSxcblx0XHRob3Vyczogcm91bmRUb3dhcmRzWmVybyhtaWxsaXNlY29uZHMgLyAzNjAwMDAwKSAlIDI0LFxuXHRcdG1pbnV0ZXM6IHJvdW5kVG93YXJkc1plcm8obWlsbGlzZWNvbmRzIC8gNjAwMDApICUgNjAsXG5cdFx0c2Vjb25kczogcm91bmRUb3dhcmRzWmVybyhtaWxsaXNlY29uZHMgLyAxMDAwKSAlIDYwLFxuXHRcdG1pbGxpc2Vjb25kczogcm91bmRUb3dhcmRzWmVybyhtaWxsaXNlY29uZHMpICUgMTAwMCxcblx0XHRtaWNyb3NlY29uZHM6IHJvdW5kVG93YXJkc1plcm8obWlsbGlzZWNvbmRzICogMTAwMCkgJSAxMDAwLFxuXHRcdG5hbm9zZWNvbmRzOiByb3VuZFRvd2FyZHNaZXJvKG1pbGxpc2Vjb25kcyAqIDFlNikgJSAxMDAwXG5cdH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhcnNlTWlsbGlzZWNvbmRzID0gcmVxdWlyZSgncGFyc2UtbXMnKTtcblxuY29uc3QgcGx1cmFsaXplID0gKHdvcmQsIGNvdW50KSA9PiBjb3VudCA9PT0gMSA/IHdvcmQgOiBgJHt3b3JkfXNgO1xuXG5jb25zdCBTRUNPTkRfUk9VTkRJTkdfRVBTSUxPTiA9IDAuMDAwMDAwMTtcblxubW9kdWxlLmV4cG9ydHMgPSAobWlsbGlzZWNvbmRzLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKCFOdW1iZXIuaXNGaW5pdGUobWlsbGlzZWNvbmRzKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZmluaXRlIG51bWJlcicpO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMuY29sb25Ob3RhdGlvbikge1xuXHRcdG9wdGlvbnMuY29tcGFjdCA9IGZhbHNlO1xuXHRcdG9wdGlvbnMuZm9ybWF0U3ViTWlsbGlzZWNvbmRzID0gZmFsc2U7XG5cdFx0b3B0aW9ucy5zZXBhcmF0ZU1pbGxpc2Vjb25kcyA9IGZhbHNlO1xuXHRcdG9wdGlvbnMudmVyYm9zZSA9IGZhbHNlO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMuY29tcGFjdCkge1xuXHRcdG9wdGlvbnMuc2Vjb25kc0RlY2ltYWxEaWdpdHMgPSAwO1xuXHRcdG9wdGlvbnMubWlsbGlzZWNvbmRzRGVjaW1hbERpZ2l0cyA9IDA7XG5cdH1cblxuXHRjb25zdCByZXN1bHQgPSBbXTtcblxuXHRjb25zdCBmbG9vckRlY2ltYWxzID0gKHZhbHVlLCBkZWNpbWFsRGlnaXRzKSA9PiB7XG5cdFx0Y29uc3QgZmxvb3JlZEludGVyaW1WYWx1ZSA9IE1hdGguZmxvb3IoKHZhbHVlICogKDEwICoqIGRlY2ltYWxEaWdpdHMpKSArIFNFQ09ORF9ST1VORElOR19FUFNJTE9OKTtcblx0XHRjb25zdCBmbG9vcmVkVmFsdWUgPSBNYXRoLnJvdW5kKGZsb29yZWRJbnRlcmltVmFsdWUpIC8gKDEwICoqIGRlY2ltYWxEaWdpdHMpO1xuXHRcdHJldHVybiBmbG9vcmVkVmFsdWUudG9GaXhlZChkZWNpbWFsRGlnaXRzKTtcblx0fTtcblxuXHRjb25zdCBhZGQgPSAodmFsdWUsIGxvbmcsIHNob3J0LCB2YWx1ZVN0cmluZykgPT4ge1xuXHRcdGlmICgocmVzdWx0Lmxlbmd0aCA9PT0gMCB8fCAhb3B0aW9ucy5jb2xvbk5vdGF0aW9uKSAmJiB2YWx1ZSA9PT0gMCAmJiAhKG9wdGlvbnMuY29sb25Ob3RhdGlvbiAmJiBzaG9ydCA9PT0gJ20nKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlU3RyaW5nID0gKHZhbHVlU3RyaW5nIHx8IHZhbHVlIHx8ICcwJykudG9TdHJpbmcoKTtcblx0XHRsZXQgcHJlZml4O1xuXHRcdGxldCBzdWZmaXg7XG5cdFx0aWYgKG9wdGlvbnMuY29sb25Ob3RhdGlvbikge1xuXHRcdFx0cHJlZml4ID0gcmVzdWx0Lmxlbmd0aCA+IDAgPyAnOicgOiAnJztcblx0XHRcdHN1ZmZpeCA9ICcnO1xuXHRcdFx0Y29uc3Qgd2hvbGVEaWdpdHMgPSB2YWx1ZVN0cmluZy5pbmNsdWRlcygnLicpID8gdmFsdWVTdHJpbmcuc3BsaXQoJy4nKVswXS5sZW5ndGggOiB2YWx1ZVN0cmluZy5sZW5ndGg7XG5cdFx0XHRjb25zdCBtaW5MZW5ndGggPSByZXN1bHQubGVuZ3RoID4gMCA/IDIgOiAxO1xuXHRcdFx0dmFsdWVTdHJpbmcgPSAnMCcucmVwZWF0KE1hdGgubWF4KDAsIG1pbkxlbmd0aCAtIHdob2xlRGlnaXRzKSkgKyB2YWx1ZVN0cmluZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJlZml4ID0gJyc7XG5cdFx0XHRzdWZmaXggPSBvcHRpb25zLnZlcmJvc2UgPyAnICcgKyBwbHVyYWxpemUobG9uZywgdmFsdWUpIDogc2hvcnQ7XG5cdFx0fVxuXG5cdFx0cmVzdWx0LnB1c2gocHJlZml4ICsgdmFsdWVTdHJpbmcgKyBzdWZmaXgpO1xuXHR9O1xuXG5cdGNvbnN0IHBhcnNlZCA9IHBhcnNlTWlsbGlzZWNvbmRzKG1pbGxpc2Vjb25kcyk7XG5cblx0YWRkKE1hdGgudHJ1bmMocGFyc2VkLmRheXMgLyAzNjUpLCAneWVhcicsICd5Jyk7XG5cdGFkZChwYXJzZWQuZGF5cyAlIDM2NSwgJ2RheScsICdkJyk7XG5cdGFkZChwYXJzZWQuaG91cnMsICdob3VyJywgJ2gnKTtcblx0YWRkKHBhcnNlZC5taW51dGVzLCAnbWludXRlJywgJ20nKTtcblxuXHRpZiAoXG5cdFx0b3B0aW9ucy5zZXBhcmF0ZU1pbGxpc2Vjb25kcyB8fFxuXHRcdG9wdGlvbnMuZm9ybWF0U3ViTWlsbGlzZWNvbmRzIHx8XG5cdFx0KCFvcHRpb25zLmNvbG9uTm90YXRpb24gJiYgbWlsbGlzZWNvbmRzIDwgMTAwMClcblx0KSB7XG5cdFx0YWRkKHBhcnNlZC5zZWNvbmRzLCAnc2Vjb25kJywgJ3MnKTtcblx0XHRpZiAob3B0aW9ucy5mb3JtYXRTdWJNaWxsaXNlY29uZHMpIHtcblx0XHRcdGFkZChwYXJzZWQubWlsbGlzZWNvbmRzLCAnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblx0XHRcdGFkZChwYXJzZWQubWljcm9zZWNvbmRzLCAnbWljcm9zZWNvbmQnLCAnXHUwMEI1cycpO1xuXHRcdFx0YWRkKHBhcnNlZC5uYW5vc2Vjb25kcywgJ25hbm9zZWNvbmQnLCAnbnMnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgbWlsbGlzZWNvbmRzQW5kQmVsb3cgPVxuXHRcdFx0XHRwYXJzZWQubWlsbGlzZWNvbmRzICtcblx0XHRcdFx0KHBhcnNlZC5taWNyb3NlY29uZHMgLyAxMDAwKSArXG5cdFx0XHRcdChwYXJzZWQubmFub3NlY29uZHMgLyAxZTYpO1xuXG5cdFx0XHRjb25zdCBtaWxsaXNlY29uZHNEZWNpbWFsRGlnaXRzID1cblx0XHRcdFx0dHlwZW9mIG9wdGlvbnMubWlsbGlzZWNvbmRzRGVjaW1hbERpZ2l0cyA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHRcdG9wdGlvbnMubWlsbGlzZWNvbmRzRGVjaW1hbERpZ2l0cyA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Y29uc3Qgcm91bmRlZE1pbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzQW5kQmVsb3cgPj0gMSA/XG5cdFx0XHRcdE1hdGgucm91bmQobWlsbGlzZWNvbmRzQW5kQmVsb3cpIDpcblx0XHRcdFx0TWF0aC5jZWlsKG1pbGxpc2Vjb25kc0FuZEJlbG93KTtcblxuXHRcdFx0Y29uc3QgbWlsbGlzZWNvbmRzU3RyaW5nID0gbWlsbGlzZWNvbmRzRGVjaW1hbERpZ2l0cyA/XG5cdFx0XHRcdG1pbGxpc2Vjb25kc0FuZEJlbG93LnRvRml4ZWQobWlsbGlzZWNvbmRzRGVjaW1hbERpZ2l0cykgOlxuXHRcdFx0XHRyb3VuZGVkTWlsaXNlY29uZHM7XG5cblx0XHRcdGFkZChcblx0XHRcdFx0TnVtYmVyLnBhcnNlRmxvYXQobWlsbGlzZWNvbmRzU3RyaW5nLCAxMCksXG5cdFx0XHRcdCdtaWxsaXNlY29uZCcsXG5cdFx0XHRcdCdtcycsXG5cdFx0XHRcdG1pbGxpc2Vjb25kc1N0cmluZ1xuXHRcdFx0KTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3Qgc2Vjb25kcyA9IChtaWxsaXNlY29uZHMgLyAxMDAwKSAlIDYwO1xuXHRcdGNvbnN0IHNlY29uZHNEZWNpbWFsRGlnaXRzID1cblx0XHRcdHR5cGVvZiBvcHRpb25zLnNlY29uZHNEZWNpbWFsRGlnaXRzID09PSAnbnVtYmVyJyA/XG5cdFx0XHRcdG9wdGlvbnMuc2Vjb25kc0RlY2ltYWxEaWdpdHMgOlxuXHRcdFx0XHQxO1xuXHRcdGNvbnN0IHNlY29uZHNGaXhlZCA9IGZsb29yRGVjaW1hbHMoc2Vjb25kcywgc2Vjb25kc0RlY2ltYWxEaWdpdHMpO1xuXHRcdGNvbnN0IHNlY29uZHNTdHJpbmcgPSBvcHRpb25zLmtlZXBEZWNpbWFsc09uV2hvbGVTZWNvbmRzID9cblx0XHRcdHNlY29uZHNGaXhlZCA6XG5cdFx0XHRzZWNvbmRzRml4ZWQucmVwbGFjZSgvXFwuMCskLywgJycpO1xuXHRcdGFkZChOdW1iZXIucGFyc2VGbG9hdChzZWNvbmRzU3RyaW5nLCAxMCksICdzZWNvbmQnLCAncycsIHNlY29uZHNTdHJpbmcpO1xuXHR9XG5cblx0aWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gJzAnICsgKG9wdGlvbnMudmVyYm9zZSA/ICcgbWlsbGlzZWNvbmRzJyA6ICdtcycpO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMuY29tcGFjdCkge1xuXHRcdHJldHVybiByZXN1bHRbMF07XG5cdH1cblxuXHRpZiAodHlwZW9mIG9wdGlvbnMudW5pdENvdW50ID09PSAnbnVtYmVyJykge1xuXHRcdGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnMuY29sb25Ob3RhdGlvbiA/ICcnIDogJyAnO1xuXHRcdHJldHVybiByZXN1bHQuc2xpY2UoMCwgTWF0aC5tYXgob3B0aW9ucy51bml0Q291bnQsIDEpKS5qb2luKHNlcGFyYXRvcik7XG5cdH1cblxuXHRyZXR1cm4gb3B0aW9ucy5jb2xvbk5vdGF0aW9uID8gcmVzdWx0LmpvaW4oJycpIDogcmVzdWx0LmpvaW4oJyAnKTtcbn07XG4iLCAiaW1wb3J0IHsgQXBwLCBNYXJrZG93blZpZXcsIFBsdWdpbiwgZGVib3VuY2UsIEVkaXRvciwgTW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtcclxuICBSZWFkaW5nVGltZVNldHRpbmdzVGFiLFxyXG4gIFJlYWRpbmdUaW1lU2V0dGluZ3MsXHJcbiAgUlRfREVGQVVMVF9TRVRUSU5HUyxcclxufSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xyXG5pbXBvcnQgeyByZWFkaW5nVGltZVRleHQgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFkaW5nVGltZSBleHRlbmRzIFBsdWdpbiB7XHJcbiAgc2V0dGluZ3M6IFJlYWRpbmdUaW1lU2V0dGluZ3M7XHJcbiAgc3RhdHVzQmFyOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcbiAgICB0aGlzLnN0YXR1c0JhciA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xyXG4gICAgdGhpcy5zdGF0dXNCYXIuc2V0VGV4dChcIlwiKTtcclxuXHJcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFJlYWRpbmdUaW1lU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcbiAgICAvLyBUaGlzIGFkZHMgYW4gZWRpdG9yIGNvbW1hbmQgdGhhdCBjYW4gcGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvbiB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2VcclxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XHJcbiAgICAgIGlkOiBcInJlYWRpbmctdGltZS1lZGl0b3ItY29tbWFuZFwiLFxyXG4gICAgICBuYW1lOiBcIlNlbGVjdGVkIFRleHRcIixcclxuICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XHJcbiAgICAgICAgbmV3IFJlYWRpbmdUaW1lTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgdGhpcykub3BlbigpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxyXG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJsYXlvdXQtY2hhbmdlXCIsIHRoaXMuY2FsY3VsYXRlUmVhZGluZ1RpbWUpXHJcbiAgICApO1xyXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxyXG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJmaWxlLW9wZW5cIiwgdGhpcy5jYWxjdWxhdGVSZWFkaW5nVGltZSlcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxyXG4gICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oXHJcbiAgICAgICAgXCJlZGl0b3ItY2hhbmdlXCIsXHJcbiAgICAgICAgZGVib3VuY2UodGhpcy5jYWxjdWxhdGVSZWFkaW5nVGltZSwgMTAwMClcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZVJlYWRpbmdUaW1lID0gKCkgPT4ge1xyXG4gICAgY29uc3QgbWRWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcclxuICAgIGlmIChtZFZpZXcgJiYgbWRWaWV3LmdldFZpZXdEYXRhKCkpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGluZ1RpbWVUZXh0KG1kVmlldy5nZXRWaWV3RGF0YSgpLCB0aGlzKTtcclxuICAgICAgdGhpcy5zdGF0dXNCYXIuc2V0VGV4dChgJHtyZXN1bHR9YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0YXR1c0Jhci5zZXRUZXh0KFwiMCBtaW4gcmVhZFwiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAge30sXHJcbiAgICAgIFJUX0RFRkFVTFRfU0VUVElOR1MsXHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZERhdGEoKVxyXG4gICAgKSBhcyBSZWFkaW5nVGltZVNldHRpbmdzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFJlYWRpbmdUaW1lTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgcGx1Z2luOiBSZWFkaW5nVGltZTtcclxuICBlZGl0b3I6IEVkaXRvcjtcclxuXHJcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCBwbHVnaW46IFJlYWRpbmdUaW1lKSB7XHJcbiAgICBzdXBlcihhcHApO1xyXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIG9uT3BlbigpIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsLCB0aXRsZUVsIH0gPSB0aGlzO1xyXG4gICAgdGl0bGVFbC5zZXRUZXh0KFwiUmVhZGluZyBUaW1lIG9mIFNlbGVjdGVkIFRleHRcIik7XHJcbiAgICBjb25zdCBzdGF0cyA9IHJlYWRpbmdUaW1lVGV4dCh0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKSwgdGhpcy5wbHVnaW4pO1xyXG4gICAgY29udGVudEVsLnNldFRleHQoYCR7c3RhdHN9IChhdCAke3RoaXMucGx1Z2luLnNldHRpbmdzLnJlYWRpbmdTcGVlZH0gd3BtKWApO1xyXG4gIH1cclxuXHJcbiAgb25DbG9zZSgpIHtcclxuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG4gICAgY29udGVudEVsLmVtcHR5KCk7XHJcbiAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBSZWFkaW5nVGltZSBmcm9tIFwiLi9tYWluXCI7XG5cbmV4cG9ydCBlbnVtIFJlYWRpbmdUaW1lRm9ybWF0IHtcbiAgRGVmYXVsdCA9IFwiZGVmYXVsdFwiLFxuICBDb21wYWN0ID0gXCJjb21wYWN0XCIsXG4gIFNpbXBsZSA9IFwic2ltcGxlXCIsXG4gIFZlcmJvc2UgPSBcInZlcmJvc2VcIixcbiAgRGlnaXRhbCA9IFwiZGlnaXRhbFwiLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRpbmdUaW1lU2V0dGluZ3Mge1xuICByZWFkaW5nU3BlZWQ6IG51bWJlcjtcbiAgZm9ybWF0OiBSZWFkaW5nVGltZUZvcm1hdDtcbiAgYXBwZW5kVGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgUlRfREVGQVVMVF9TRVRUSU5HUzogUmVhZGluZ1RpbWVTZXR0aW5ncyA9IHtcbiAgcmVhZGluZ1NwZWVkOiAyMDAsXG4gIGZvcm1hdDogUmVhZGluZ1RpbWVGb3JtYXQuRGVmYXVsdCxcbiAgYXBwZW5kVGV4dDogXCJyZWFkXCIsXG59O1xuXG5leHBvcnQgY2xhc3MgUmVhZGluZ1RpbWVTZXR0aW5nc1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICBwbHVnaW46IFJlYWRpbmdUaW1lO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFJlYWRpbmdUaW1lKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJSZWFkaW5nIHNwZWVkXCIpXG4gICAgICAuc2V0RGVzYyhcIldvcmRzIHBlciBtaW51dGUgdXNlZCBmb3IgcmVhZGluZyBzcGVlZCAoZGVmYXVsdDogMjAwKS5cIilcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFeGFtcGxlOiAyMDBcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVhZGluZ1NwZWVkLnRvU3RyaW5nKCkpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVhZGluZ1NwZWVkID0gcGFyc2VJbnQodmFsdWUudHJpbSgpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luXG4gICAgICAgICAgICAgIC5zYXZlU2V0dGluZ3MoKVxuICAgICAgICAgICAgICAudGhlbih0aGlzLnBsdWdpbi5jYWxjdWxhdGVSZWFkaW5nVGltZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIG5ldyBTZXR0aW5nKHRoaXMuY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkZvcm1hdFwiKVxuICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIG91dHB1dCBmb3JtYXRcIilcbiAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+XG4gICAgICAgIGRyb3Bkb3duXG4gICAgICAgICAgLmFkZE9wdGlvbihSZWFkaW5nVGltZUZvcm1hdC5EZWZhdWx0LCBcIkRlZmF1bHQgKDEwIG1pbilcIilcbiAgICAgICAgICAuYWRkT3B0aW9uKFJlYWRpbmdUaW1lRm9ybWF0LkNvbXBhY3QsIFwiQ29tcGFjdCAoMTBtKVwiKVxuICAgICAgICAgIC5hZGRPcHRpb24oUmVhZGluZ1RpbWVGb3JtYXQuU2ltcGxlLCBcIlNpbXBsZSAoMTBtIDRzKVwiKVxuICAgICAgICAgIC5hZGRPcHRpb24oXG4gICAgICAgICAgICBSZWFkaW5nVGltZUZvcm1hdC5WZXJib3NlLFxuICAgICAgICAgICAgXCJWZXJib3NlICgxMCBtaW51dGVzIDQgc2Vjb25kcylcIlxuICAgICAgICAgIClcbiAgICAgICAgICAuYWRkT3B0aW9uKFJlYWRpbmdUaW1lRm9ybWF0LkRpZ2l0YWwsIFwiQ29sb24gTm90YXRpb24gKDEwOjA0KVwiKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5mb3JtYXQpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9ybWF0ID0gdmFsdWUgYXMgUmVhZGluZ1RpbWVGb3JtYXQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpblxuICAgICAgICAgICAgICAuc2F2ZVNldHRpbmdzKClcbiAgICAgICAgICAgICAgLnRoZW4odGhpcy5wbHVnaW4uY2FsY3VsYXRlUmVhZGluZ1RpbWUpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQXBwZW5kIFRleHRcIilcbiAgICAgIC5zZXREZXNjKFwiQXBwZW5kICdyZWFkJyB0byBmb3JtYXR0ZWQgc3RyaW5nLlwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBwZW5kVGV4dClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcHBlbmRUZXh0ID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW5cbiAgICAgICAgICAgICAgLnNhdmVTZXR0aW5ncygpXG4gICAgICAgICAgICAgIC50aGVuKHRoaXMucGx1Z2luLmNhbGN1bGF0ZVJlYWRpbmdUaW1lKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxufVxuIiwgIi8qIVxuICogcmVhZGluZy10aW1lXG4gKiBDb3B5cmlnaHQgKGMpIE5pY29sYXMgR3J5bWFuIDxuZ3J5bWFuQGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgT3B0aW9ucyxcbiAgUmVhZGluZ1RpbWVTdGF0cyxcbiAgV29yZENvdW50U3RhdHMsXG4gIFJlYWRpbmdUaW1lUmVzdWx0LFxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG50eXBlIFdvcmRCb3VuZEZ1bmN0aW9uID0gT3B0aW9uc1tcIndvcmRCb3VuZFwiXTtcblxuZnVuY3Rpb24gY29kZUlzSW5SYW5nZXMobnVtYmVyOiBudW1iZXIsIGFycmF5T2ZSYW5nZXM6IG51bWJlcltdW10pIHtcbiAgcmV0dXJuIGFycmF5T2ZSYW5nZXMuc29tZShcbiAgICAoW2xvd2VyQm91bmQsIHVwcGVyQm91bmRdKSA9PiBsb3dlckJvdW5kIDw9IG51bWJlciAmJiBudW1iZXIgPD0gdXBwZXJCb3VuZFxuICApO1xufVxuXG5jb25zdCBpc0NKSzogV29yZEJvdW5kRnVuY3Rpb24gPSAoYykgPT4ge1xuICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgLy8gSGVscCB3YW50ZWQhXG4gIC8vIFRoaXMgc2hvdWxkIGJlIGdvb2QgZm9yIG1vc3QgY2FzZXMsIGJ1dCBpZiB5b3UgZmluZCBpdCB1bnNhdGlzZmFjdG9yeVxuICAvLyAoZS5nLiBzb21lIG90aGVyIGxhbmd1YWdlIHdoZXJlIGVhY2ggY2hhcmFjdGVyIHNob3VsZCBiZSBzdGFuZGFsb25lIHdvcmRzKSxcbiAgLy8gY29udHJpYnV0aW9ucyB3ZWxjb21lIVxuICByZXR1cm4gY29kZUlzSW5SYW5nZXMoY2hhckNvZGUsIFtcbiAgICAvLyBIaXJhZ2FuYSAoS2F0YWthbmEgbm90IGluY2x1ZGVkIG9uIHB1cnBvc2UsXG4gICAgLy8gY29udGV4dDogaHR0cHM6Ly9naXRodWIuY29tL25ncnltYW4vcmVhZGluZy10aW1lL3B1bGwvMzUjaXNzdWVjb21tZW50LTg1MzM2NDUyNilcbiAgICAvLyBJZiB5b3UgdGhpbmsgS2F0YWthbmEgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCBoYXZlIHNvbGlkIHJlYXNvbnMsIGltcHJvdmVtZW50IGlzIHdlbGNvbWVkXG4gICAgWzB4MzA0MCwgMHgzMDlmXSxcbiAgICAvLyBDSksgVW5pZmllZCBpZGVvZ3JhcGhzXG4gICAgWzB4NGUwMCwgMHg5ZmZmXSxcbiAgICAvLyBIYW5ndWxcbiAgICBbMHhhYzAwLCAweGQ3YTNdLFxuICAgIC8vIENKSyBleHRlbnNpb25zXG4gICAgWzB4MjAwMDAsIDB4MmViZTBdLFxuICBdKTtcbn07XG5cbmNvbnN0IGlzQW5zaVdvcmRCb3VuZDogV29yZEJvdW5kRnVuY3Rpb24gPSAoYykgPT4ge1xuICByZXR1cm4gXCIgXFxuXFxyXFx0XCIuaW5jbHVkZXMoYyk7XG59O1xuXG5jb25zdCBpc1B1bmN0dWF0aW9uOiBXb3JkQm91bmRGdW5jdGlvbiA9IChjKSA9PiB7XG4gIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY29kZUlzSW5SYW5nZXMoY2hhckNvZGUsIFtcbiAgICBbMHgyMSwgMHgyZl0sXG4gICAgWzB4M2EsIDB4NDBdLFxuICAgIFsweDViLCAweDYwXSxcbiAgICBbMHg3YiwgMHg3ZV0sXG4gICAgLy8gQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXG4gICAgWzB4MzAwMCwgMHgzMDNmXSxcbiAgICAvLyBGdWxsLXdpZHRoIEFTQ0lJIHB1bmN0dWF0aW9uIHZhcmlhbnRzXG4gICAgWzB4ZmYwMCwgMHhmZmVmXSxcbiAgXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY291bnRXb3JkcyhcbiAgdGV4dDogc3RyaW5nLFxuICBvcHRpb25zOiBPcHRpb25zID0ge31cbik6IFdvcmRDb3VudFN0YXRzIHtcbiAgbGV0IHdvcmRzID0gMCxcbiAgICBzdGFydCA9IDAsXG4gICAgZW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICBjb25zdCB7IHdvcmRCb3VuZDogaXNXb3JkQm91bmQgPSBpc0Fuc2lXb3JkQm91bmQgfSA9IG9wdGlvbnM7XG5cbiAgLy8gZmV0Y2ggYm91bmRzXG4gIHdoaWxlIChpc1dvcmRCb3VuZCh0ZXh0W3N0YXJ0XSkpIHN0YXJ0Kys7XG4gIHdoaWxlIChpc1dvcmRCb3VuZCh0ZXh0W2VuZF0pKSBlbmQtLTtcblxuICAvLyBBZGQgYSB0cmFpbGluZyB3b3JkIGJvdW5kIHRvIG1ha2UgaGFuZGxpbmcgZWRnZXMgbW9yZSBjb252ZW5pZW50XG4gIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gYCR7dGV4dH1cXG5gO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHdvcmRzXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIC8vIEEgQ0pLIGNoYXJhY3RlciBpcyBhIGFsd2F5cyB3b3JkO1xuICAgIC8vIEEgbm9uLXdvcmQgYm91bmQgZm9sbG93ZWQgYnkgYSB3b3JkIGJvdW5kIC8gQ0pLIGlzIHRoZSBlbmQgb2YgYSB3b3JkLlxuICAgIGlmIChcbiAgICAgIGlzQ0pLKG5vcm1hbGl6ZWRUZXh0W2ldKSB8fFxuICAgICAgKCFpc1dvcmRCb3VuZChub3JtYWxpemVkVGV4dFtpXSkgJiZcbiAgICAgICAgKGlzV29yZEJvdW5kKG5vcm1hbGl6ZWRUZXh0W2kgKyAxXSkgfHwgaXNDSksobm9ybWFsaXplZFRleHRbaSArIDFdKSkpXG4gICAgKSB7XG4gICAgICB3b3JkcysrO1xuICAgIH1cbiAgICAvLyBJbiBjYXNlIG9mIENKSyBmb2xsb3dlZCBieSBwdW5jdHVhdGlvbnMsIHRob3NlIGNoYXJhY3RlcnMgaGF2ZSB0byBiZSBlYXRlbiBhcyB3ZWxsXG4gICAgaWYgKGlzQ0pLKG5vcm1hbGl6ZWRUZXh0W2ldKSkge1xuICAgICAgd2hpbGUgKFxuICAgICAgICBpIDw9IGVuZCAmJlxuICAgICAgICAoaXNQdW5jdHVhdGlvbihub3JtYWxpemVkVGV4dFtpICsgMV0pIHx8XG4gICAgICAgICAgaXNXb3JkQm91bmQobm9ybWFsaXplZFRleHRbaSArIDFdKSlcbiAgICAgICkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHRvdGFsOiB3b3JkcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZGluZ1RpbWVXaXRoQ291bnQoXG4gIHdvcmRzOiBXb3JkQ291bnRTdGF0cyxcbiAgb3B0aW9uczogT3B0aW9ucyA9IHt9XG4pOiBSZWFkaW5nVGltZVN0YXRzIHtcbiAgY29uc3QgeyB3b3Jkc1Blck1pbnV0ZSA9IDIwMCB9ID0gb3B0aW9ucztcbiAgLy8gcmVhZGluZyB0aW1lIHN0YXRzXG4gIGNvbnN0IG1pbnV0ZXMgPSB3b3Jkcy50b3RhbCAvIHdvcmRzUGVyTWludXRlO1xuICAvLyBNYXRoLnJvdW5kIHVzZWQgdG8gcmVzb2x2ZSBmbG9hdGluZyBwb2ludCBmdW5raW5lc3NcbiAgLy8gICBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2NkL0UxOTk1Ny0wMS84MDYtMzU2OC9uY2dfZ29sZGJlcmcuaHRtbFxuICBjb25zdCB0aW1lID0gTWF0aC5yb3VuZChtaW51dGVzICogNjAgKiAxMDAwKTtcbiAgY29uc3QgZGlzcGxheWVkID0gTWF0aC5jZWlsKHBhcnNlRmxvYXQobWludXRlcy50b0ZpeGVkKDIpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtaW51dGVzOiBkaXNwbGF5ZWQsXG4gICAgdGltZSxcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhZGluZ1RpbWUoXG4gIHRleHQ6IHN0cmluZyxcbiAgb3B0aW9uczogT3B0aW9ucyA9IHt9XG4pOiBSZWFkaW5nVGltZVJlc3VsdCB7XG4gIGNvbnN0IHdvcmRzID0gY291bnRXb3Jkcyh0ZXh0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWFkaW5nVGltZVdpdGhDb3VudCh3b3Jkcywgb3B0aW9ucyksXG4gICAgd29yZHMsXG4gIH07XG59XG4iLCAiaW1wb3J0IFJlYWRUaW1lIGZyb20gXCIuL2xpYi9yZWFkaW5nLXRpbWVcIjtcbmltcG9ydCBQcmV0dHlNaWxsaXNlY29uZHMgZnJvbSBcInByZXR0eS1tc1wiO1xuaW1wb3J0IFJlYWRpbmdUaW1lIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IFJlYWRpbmdUaW1lRm9ybWF0IH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRpbmdUaW1lVGV4dCh0ZXh0OiBzdHJpbmcsIHBsdWdpbjogUmVhZGluZ1RpbWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gUmVhZFRpbWUodGV4dCwge1xuICAgIHdvcmRzUGVyTWludXRlOiBwbHVnaW4uc2V0dGluZ3MucmVhZGluZ1NwZWVkLFxuICB9KTtcbiAgbGV0IG9wdGlvbnM6IFByZXR0eU1pbGxpc2Vjb25kcy5PcHRpb25zID0geyBzZWNvbmRzRGVjaW1hbERpZ2l0czogMCB9O1xuXG4gIHN3aXRjaCAocGx1Z2luLnNldHRpbmdzLmZvcm1hdCkge1xuICAgIGNhc2UgUmVhZGluZ1RpbWVGb3JtYXQuU2ltcGxlOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZWFkaW5nVGltZUZvcm1hdC5Db21wYWN0OlxuICAgICAgaWYgKHJlc3VsdC50aW1lID4gMzYwMDAwMCkge1xuICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB1bml0Q291bnQ6IDIgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGNvbXBhY3Q6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVhZGluZ1RpbWVGb3JtYXQuVmVyYm9zZTpcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHZlcmJvc2U6IHRydWUgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVhZGluZ1RpbWVGb3JtYXQuRGlnaXRhbDpcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGNvbG9uTm90YXRpb246IHRydWUgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVhZGluZ1RpbWVGb3JtYXQuRGVmYXVsdDpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBsdWdpbi5zZXR0aW5ncy5hcHBlbmRUZXh0XG4gICAgICAgID8gYCR7cmVzdWx0Lm1pbnV0ZXN9IG1pbiByZWFkYFxuICAgICAgICA6IGAke3Jlc3VsdC5taW51dGVzfSBtaW5gO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IFByZXR0eU1pbGxpc2Vjb25kcyhyZXN1bHQudGltZSwgb3B0aW9ucyk7XG4gIHJldHVybiBwbHVnaW4uc2V0dGluZ3MuYXBwZW5kVGV4dFxuICAgID8gYCR7b3V0cHV0fSAke3BsdWdpbi5zZXR0aW5ncy5hcHBlbmRUZXh0fWBcbiAgICA6IG91dHB1dDtcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSw0Q0FBQUEsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxVQUFVLGtCQUFnQjtBQUNoQyxV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QUNuQixXQUFLLFdBQVcsT0FBTztBQUFBLFFBQ3JCLENBQUM7QUFBQSxRQUNEO0FBQUEsUUFDQSxNQUFNLEtBQUssU0FBUztBQUFBLE1BQ3RCO0FBQUEsSUFDRjtBQUFBO0FBQUEsRUFFTSxlQUFlO0FBQUE7QUFDbkIsWUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsSUFDbkM7QUFBQTtBQUNGO0FBRUEsSUFBTSxtQkFBTixjQUErQix1QkFBTTtBQUFBLEVBSW5DLFlBQVksS0FBVSxRQUFnQixRQUFxQjtBQUN6RCxVQUFNLEdBQUc7QUFDVCxTQUFLLFNBQVM7QUFDZCxTQUFLLFNBQVM7QUFBQSxFQUNoQjtBQUFBLEVBRUEsU0FBUztBQUNQLFVBQU0sRUFBRSxXQUFXLFFBQVEsSUFBSTtBQUMvQixZQUFRLFFBQVEsK0JBQStCO0FBQy9DLFVBQU0sUUFBUSxnQkFBZ0IsS0FBSyxPQUFPLGFBQWEsR0FBRyxLQUFLLE1BQU07QUFDckUsY0FBVSxRQUFRLEdBQUcsS0FBSyxRQUFRLEtBQUssT0FBTyxTQUFTLFlBQVksT0FBTztBQUFBLEVBQzVFO0FBQUEsRUFFQSxVQUFVO0FBQ1IsVUFBTSxFQUFFLFVBQVUsSUFBSTtBQUN0QixjQUFVLE1BQU07QUFBQSxFQUNsQjtBQUNGOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgImltcG9ydF9vYnNpZGlhbiIsICJQcmV0dHlNaWxsaXNlY29uZHMiXQp9Cg==
